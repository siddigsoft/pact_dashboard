import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { MMPPermitsData, MMPStatePermitDocument } from '@/types/mmp/permits';
import { MMPPermitFileUpload } from './MMPPermitFileUpload';
import { PermitVerificationCard } from './permits/PermitVerificationCard';
import { Progress } from '@/components/ui/progress';
import { Upload, FileCheck, Send } from 'lucide-react';
import { useMMP } from '@/context/mmp/MMPContext';
import { useAppContext } from '@/context/AppContext';
import { useSiteVisitContext } from '@/context/siteVisit/SiteVisitContext';
import { supabase } from '@/integrations/supabase/client';
import { sudanStates } from '@/data/sudanStates';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import { Select, SelectTrigger, SelectContent, SelectItem, SelectValue } from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';
import { useState as useReactState } from 'react';
import { ChevronDown, ChevronRight } from 'lucide-react';

interface MMPPermitVerificationProps {
  mmpFile: any;
  onVerificationComplete?: (verificationData: any) => void;
}

const MMPPermitVerification: React.FC<MMPPermitVerificationProps> = ({
  mmpFile,
  onVerificationComplete
}) => {
  const [permits, setPermits] = useState<MMPStatePermitDocument[]>([]);
  const [localPermits, setLocalPermits] = useState<MMPStatePermitDocument[]>([]);
  const { toast } = useToast();
  const { updateMMP } = useMMP();
  const { currentUser } = useAppContext();
  const { reloadSiteVisits } = useSiteVisitContext();
  const [forwardLoading, setForwardLoading] = useState(false);
  const [hasForwarded, setHasForwarded] = useState(false);
  // Modal state for review/assignment
  const [showAssignModal, setShowAssignModal] = useReactState(false);
  const [assignmentMap, setAssignmentMap] = useReactState({} as Record<string, string>); // key: groupKey, value: coordinatorId
  const [selectedSites, setSelectedSites] = useReactState({} as Record<string, Set<string>>); // key: groupKey, value: Set of site ids
  const [batchLoading, setBatchLoading] = useReactState({} as Record<string, boolean>); // key: groupKey, value: loading state
  const [batchForwarded, setBatchForwarded] = useReactState({} as Record<string, boolean>); // key: groupKey, value: forwarded state
  const [expandedGroups, setExpandedGroups] = useReactState({} as Record<string, boolean>); // key: groupKey, value: expanded/collapsed
  const { users } = useAppContext();

  useEffect(() => {
    let cancelled = false;

    const normalizeDocs = (raw: any): MMPStatePermitDocument[] => {
      if (!raw) return [];
      if (Array.isArray(raw)) return raw as MMPStatePermitDocument[];
      if (typeof raw === 'object') {
        if ('documents' in raw && Array.isArray((raw as any).documents)) {
          return (raw as any).documents as MMPStatePermitDocument[];
        }
        const stateDocs = ((raw as any).statePermits || []).flatMap((sp: any) =>
          (sp.documents || []).map((d: any) => ({ ...d, permitType: 'state' as const, state: d?.state || sp?.stateName }))
        );
        const localDocs = ((raw as any).localPermits || []).flatMap((lp: any) =>
          (lp.documents || []).map((d: any) => ({ ...d, permitType: 'local' as const, locality: d?.locality || lp?.localityName }))
        );
        return [...stateDocs, ...localDocs];
      }
      return [];
    };


    

    const fetchFromStorage = async (): Promise<MMPStatePermitDocument[]> => {
      const bucket = 'mmp-files';
      const id = mmpFile?.id || mmpFile?.mmpId;
      if (!id) return [];
      const base = `permits/${id}`;
      try {
        const list = async (path: string) => {
          const { data, error } = await supabase.storage
            .from(bucket)
            .list(path, { limit: 100, offset: 0, sortBy: { column: 'name', order: 'asc' } });
          if (error) {
            console.error('Storage list error', path, error);
            return [] as any[];
          }
          return (data || []) as any[];
        };

        const toDocs = (
          path: string,
          files: any[],
          type: 'federal' | 'state' | 'local',
          extra?: { state?: string; locality?: string }
        ) => {
          return (files || [])
            .filter((f: any) => f && f.name && f.metadata && typeof f.metadata.size === 'number')
            .map((f: any) => {
              const fullPath = `${path}/${f.name}`.replace(/\/+/g, '/');
              const url = supabase.storage.from(bucket).getPublicUrl(fullPath).data.publicUrl;
              return {
                id: fullPath,
                fileName: f.name,
                fileUrl: url,
                uploadedAt: f.created_at || new Date().toISOString(),
                validated: false,
                permitType: type,
                ...(extra?.state ? { state: extra.state } : {}),
                ...(extra?.locality ? { locality: extra.locality } : {}),
              } as MMPStatePermitDocument;
            });
        };

        const top = await list(base);
        const hasTypeFolders = top?.some((e: any) => !e.metadata && ['federal', 'state', 'local'].includes(e.name));
        let docs: MMPStatePermitDocument[] = [];

        if (hasTypeFolders) {
          const fedEntries = await list(`${base}/federal`);
          const fedFiles = (fedEntries || []).filter((e: any) => !!e.metadata);
          docs = docs.concat(toDocs(`${base}/federal`, fedFiles, 'federal'));

          const stateEntries = await list(`${base}/state`);
          const stateFolders = (stateEntries || []).filter((e: any) => !e.metadata);
          for (const sf of stateFolders) {
            const stateFilesEntries = await list(`${base}/state/${sf.name}`);
            const stateFiles = (stateFilesEntries || []).filter((e: any) => !!e.metadata);
            docs = docs.concat(toDocs(`${base}/state/${sf.name}`, stateFiles, 'state', { state: sf.name }));
          }
          // Also handle flat files directly under /state (no nested folders)
          const flatStateFiles = (stateEntries || []).filter((e: any) => !!e.metadata);
          if (flatStateFiles?.length) {
            docs = docs.concat(toDocs(`${base}/state`, flatStateFiles, 'state'));
          }

          const localEntries = await list(`${base}/local`);
          const localFolders = (localEntries || []).filter((e: any) => !e.metadata);
          for (const lf of localFolders) {
            const localFilesEntries = await list(`${base}/local/${lf.name}`);
            const localFiles = (localFilesEntries || []).filter((e: any) => !!e.metadata);
            docs = docs.concat(toDocs(`${base}/local/${lf.name}`, localFiles, 'local', { locality: lf.name }));
          }
          const flatLocalFiles = (localEntries || []).filter((e: any) => !!e.metadata);
          if (flatLocalFiles?.length) {
            docs = docs.concat(toDocs(`${base}/local`, flatLocalFiles, 'local'));
          }
        } else {
          // Backward compatibility: files directly under base. We default to 'federal' to at least render them.
          const entries = await list(base);
          const files = (entries || []).filter((e: any) => !!e.metadata);
          docs = docs.concat(toDocs(base, files, 'federal'));
        }

        return docs;
      } catch (e) {
        console.error('fetchFromStorage failed', e);
        return [];
      }
    };

    const load = async () => {
      const storageDocs = await fetchFromStorage();

      // Normalize DB-persisted documents
      const persistedRaw = mmpFile?.permits;
      const persistedDocs = normalizeDocs(persistedRaw);

      // Helper: merge by id or fileName
      const mergeLists = (a: MMPStatePermitDocument[], b: MMPStatePermitDocument[]) => {
        const aByKey = new Map<string, MMPStatePermitDocument>();
        const keyOf = (d: MMPStatePermitDocument) => (d.id || d.fileName || '').toString();
        a.forEach(d => aByKey.set(keyOf(d), d));
        const out: MMPStatePermitDocument[] = [];
        // start with storage list (has correct URLs/paths)
        a.forEach(sd => {
          const key = keyOf(sd);
          const pd = b.find(x => keyOf(x) === key) || undefined;
          out.push({
            ...sd,
            // prefer persisted decision/notes
            status: pd?.status ?? sd.status,
            verificationNotes: pd?.verificationNotes ?? sd.verificationNotes,
            verifiedAt: pd?.verifiedAt ?? sd.verifiedAt,
            verifiedBy: pd?.verifiedBy ?? sd.verifiedBy,
            // ensure geo fields remain
            state: sd.state ?? pd?.state,
            locality: sd.locality ?? pd?.locality,
          });
        });
        // include any persisted docs that aren't in storage (edge cases)
        b.forEach(pd => {
          const key = keyOf(pd);
          if (!aByKey.has(key)) out.push(pd);
        });
        return out;
      };

      let finalDocs: MMPStatePermitDocument[] = [];
      if (storageDocs.length > 0) {
        finalDocs = mergeLists(storageDocs, persistedDocs);
      } else {
        finalDocs = persistedDocs;
      }

      if (!cancelled) {
        setPermits(finalDocs.filter(d => d.permitType === 'federal' || d.permitType === 'state'));
        setLocalPermits(finalDocs.filter(d => d.permitType === 'local'));
      }
    };

    load();

    return () => {
      cancelled = true;
    };
  }, [mmpFile?.id, mmpFile?.mmpId, mmpFile?.permits]);

  const handleDeletePermit = async (permitId: string) => {
    try {
      const doc = localPermits.find(p => p.id === permitId) || permits.find(p => p.id === permitId);
      if (!doc) {
        toast({ title: 'Permit not found', description: 'Could not locate the selected permit.', variant: 'destructive' });
        return;
      }

      try {
        const bucket = 'mmp-files';
        const path = typeof doc.id === 'string' && doc.id.includes('/') ? doc.id : '';
        if (path) {
          const { error: rmError } = await supabase.storage.from(bucket).remove([path]);
          if (rmError) {
            console.warn('Storage remove failed (non-fatal):', rmError);
          }
        }
      } catch (e) {
        console.warn('Storage remove threw (non-fatal):', e);
      }

      if (doc.permitType === 'local') {
        const updatedLocalPermits = localPermits.filter(p => p.id !== permitId);
        setLocalPermits(updatedLocalPermits);
        persistPermits(permits, updatedLocalPermits);
      } else {
        const updatedPermits = permits.filter(p => p.id !== permitId);
        setPermits(updatedPermits);
        persistPermits(updatedPermits, localPermits);
      }

      toast({ title: 'Permit deleted', description: `${doc.fileName} was removed.` });
    } catch (e) {
      console.warn('Delete permit failed:', e);
      toast({ title: 'Delete failed', description: 'Could not delete the permit. Please try again.', variant: 'destructive' });
    }
  };

  const notifyAdminsAndICT = async (doc: MMPStatePermitDocument, decision: 'verified' | 'rejected') => {
    try {
      const mmpId = mmpFile?.id || mmpFile?.mmpId;
      if (!mmpId) return;
      const { data: recipients } = await supabase
        .from('profiles')
        .select('id, role')
        .in('role', ['admin', 'ict']);
      const rows = (recipients || []).map(r => ({
        user_id: r.id,
        title: decision === 'verified' ? 'Permit accepted' : 'Permit rejected',
        message: `${mmpFile?.name || 'MMP'} â€¢ ${doc.fileName} ${decision}. ${doc.state ? `State: ${doc.state}. ` : ''}${doc.locality ? `Locality: ${doc.locality}. ` : ''}${doc.verificationNotes ? `Reason: ${doc.verificationNotes}` : ''}`.trim(),
        type: decision === 'verified' ? 'success' : 'warning',
        link: `/mmp/${mmpId}/verification`,
        related_entity_id: mmpId,
        related_entity_type: 'mmpFile'
      }));
      if (rows.length) await supabase.from('notifications').insert(rows);
    } catch (e) {
      console.warn('Failed to notify admins/ICT about permit decision:', e);
    }
  };

  const persistPermits = (docs: MMPStatePermitDocument[], localDocs: MMPStatePermitDocument[] = []) => {
    const now = new Date().toISOString();
    const allDocs = [...docs, ...localDocs];
    const permitsData: MMPPermitsData = {
      federal: docs.some(d => d.permitType === 'federal'),
      state: docs.some(d => d.permitType === 'state'),
      local: localDocs.some(d => d.permitType === 'local'),
      lastVerified: allDocs.some(d => d.status) ? now : undefined,
      verifiedBy: currentUser?.username || currentUser?.fullName || currentUser?.email || undefined,
      // Cast to MMPDocument[] for compatibility; downstream code handles extended fields safely
      documents: allDocs as unknown as any,
    };

    if (mmpFile?.id) {
      updateMMP(mmpFile.id, { permits: permitsData } as any);
    }
    if (onVerificationComplete) {
      onVerificationComplete(permitsData);
      // Also persist directly with retry to ensure DB state is updated even on transient failures
      (async () => {
        if (!mmpFile?.id) return;
        let attempt = 0;
        let delay = 500;
        while (attempt < 3) {
          try {
            const { error } = await supabase
              .from('mmp_files')
              .update({ permits: permitsData, updated_at: new Date().toISOString() })
              .eq('id', mmpFile.id);
            if (!error) return;
            console.warn('Persist permits attempt failed:', error?.message || error);
          } catch (e) {
            console.warn('Persist permits transport error:', e);
          }
          await new Promise(res => setTimeout(res, delay));
          delay *= 2;
          attempt++;
        }
        toast({
          title: 'Sync delayed',
          description: 'Could not sync permit changes to server. They remain locally and will retry shortly.',
          variant: 'destructive',
        });
      })();
    } else if (mmpFile?.id) {
      // Directly persist if no callback provided
      updateMMP(mmpFile.id, { permits: permitsData } as any);
    }
  };

  const handleUploadSuccess = (newPermit: MMPStatePermitDocument) => {
    if (newPermit.permitType === 'local') {
      const updatedLocalPermits = [...localPermits, newPermit];
      setLocalPermits(updatedLocalPermits);
      persistPermits(permits, updatedLocalPermits);
    } else {
      const updatedPermits = [...permits, newPermit];
      setPermits(updatedPermits);
      persistPermits(updatedPermits, localPermits);
    }
    
    toast({
      title: "Permit Uploaded",
      description: `${newPermit.fileName} has been uploaded successfully.`,
    });

    // Notify stakeholders and share entries to coordinators
    (async () => {
      try {
        const mmpId = mmpFile?.id || mmpFile?.mmpId;
        if (!mmpId) return;

        // 1) Notify FOMs and Supervisors that a permit was uploaded
        const { data: recipients } = await supabase
          .from('profiles')
          .select('id, role, hub_id')
          .in('role', ['fom', 'supervisor']);
        const rows = (recipients || []).map(r => ({
          user_id: r.id,
          title: 'Permit uploaded',
          message: `${mmpFile?.name || 'MMP'} has a new permit uploaded`,
          type: 'info',
          link: `/mmp/${mmpId}`,
          related_entity_id: mmpId,
          related_entity_type: 'mmpFile'
        }));
        if (rows.length) await supabase.from('notifications').insert(rows);

        // 2) Share entries to State Coordinators for CP review
        // Fetch entries if not present
        let entries = Array.isArray(mmpFile?.siteEntries) && mmpFile.siteEntries.length > 0
          ? mmpFile.siteEntries
          : [];
        if (!entries.length && mmpFile?.id) {
          const { data: dbEntries } = await supabase
            .from('mmp_site_entries')
            .select('state, locality')
            .eq('mmp_file_id', mmpFile.id);
          entries = dbEntries || [];
        }

        if (!entries.length) return;

        // Map entry state/locality names to ids defined in sudanStates
        const stateNameToId = new Map<string, string>();
        for (const s of sudanStates) stateNameToId.set(s.name.toLowerCase(), s.id);

        const localitiesByState = new Map<string, Map<string, string>>();
        for (const s of sudanStates) {
          const map = new Map<string, string>();
          s.localities.forEach(l => map.set(l.name.toLowerCase(), l.id));
          localitiesByState.set(s.id, map);
        }

        const targetPairs = new Set<string>(); // state_id|locality_id?
        entries.forEach((e: any) => {
          const sName = String(e.state || '').trim().toLowerCase();
          const stateId = stateNameToId.get(sName);
          if (!stateId) return;
          const locName = String(e.locality || '').trim().toLowerCase();
          const locMap = localitiesByState.get(stateId);
          const localityId = locName && locMap ? (locMap.get(locName) || '') : '';
          targetPairs.add(`${stateId}|${localityId}`);
        });

        if (targetPairs.size === 0) return;

        // Build filters and fetch coordinators
        const allStates = Array.from(new Set(Array.from(targetPairs).map(k => k.split('|')[0])));
        const { data: coords } = await supabase
          .from('profiles')
          .select('id, state_id, locality_id, role')
          .eq('role', 'coordinator')
          .in('state_id', allStates);

        const coordRows = (coords || []).filter(c => {
          // If we matched a specific locality, ensure locality match; otherwise state match is enough
          const key1 = `${c.state_id}|${c.locality_id || ''}`;
          const key2 = `${c.state_id}|`;
          return targetPairs.has(key1) || targetPairs.has(key2);
        }).map(c => ({
          user_id: c.id,
          title: 'Sites shared for CP review',
          message: `${mmpFile?.name || 'MMP'} sites have been shared for your review`,
          type: 'info',
          link: `/mmp/${mmpId}`,
          related_entity_id: mmpId,
          related_entity_type: 'mmpFile'
        }));

        if (coordRows.length) await supabase.from('notifications').insert(coordRows);
      } catch (e) {
        console.warn('Permit upload notifications/share failed:', e);
      }
    })();
  };

  const handleVerifyPermit = (permitId: string, status: 'verified' | 'rejected', notes?: string) => {
    let decidedDoc: MMPStatePermitDocument | undefined;
    // Check if it's a local permit
    const localPermitIndex = localPermits.findIndex(p => p.id === permitId);
    if (localPermitIndex !== -1) {
      const updatedLocalPermits = localPermits.map(permit => {
        if (permit.id === permitId) {
          const updated = {
            ...permit,
            status,
            verificationNotes: notes,
            verifiedAt: new Date().toISOString(),
            verifiedBy: currentUser?.username || currentUser?.fullName || currentUser?.email || 'System'
          } as MMPStatePermitDocument;
          decidedDoc = updated;
          return updated;
        }
        return permit;
      });
      setLocalPermits(updatedLocalPermits);
      persistPermits(permits, updatedLocalPermits);
      if (decidedDoc) {
        (async () => { await notifyAdminsAndICT(decidedDoc!, status); })();
      }
    } else {
      const updatedPermits = permits.map(permit => {
        if (permit.id === permitId) {
          const updated = {
            ...permit,
            status,
            verificationNotes: notes,
            verifiedAt: new Date().toISOString(),
            verifiedBy: currentUser?.username || currentUser?.fullName || currentUser?.email || 'System'
          } as MMPStatePermitDocument;
          decidedDoc = updated;
          return updated;
        }
        return permit;
      });
      setPermits(updatedPermits);
      persistPermits(updatedPermits, localPermits);
      if (decidedDoc) {
        (async () => { await notifyAdminsAndICT(decidedDoc!, status); })();
      }
    }
  };

  // Show modal instead of forwarding directly
  const forwardEntriesToCoordinators = async () => {
    setShowAssignModal(true);
  };

  // Forward a single batch (group) to the selected coordinator
  const handleForwardBatch = async (groupKey: string) => {
    setBatchLoading(b => ({ ...b, [groupKey]: true }));
    try {
      const mmpId = mmpFile?.id || mmpFile?.mmpId;
      const coordinatorId = assignmentMap[groupKey];
      const siteIds = Array.from(selectedSites[groupKey] || []);
      if (!coordinatorId || siteIds.length === 0) {
        toast({ title: 'Select sites and coordinator', description: 'Please select at least one site and a coordinator.', variant: 'destructive' });
        setBatchLoading(b => ({ ...b, [groupKey]: false }));
        return;
      }

      // Get the site entries for the selected sites
      const selectedSiteEntries = groupMap[groupKey]?.filter((site: any) => siteIds.includes(site.id)) || [];

      // Create site visit records for each selected site
      const siteVisitPromises = selectedSiteEntries.map(async (siteEntry: any) => {
        const siteVisitData = {
          siteName: siteEntry.siteName || siteEntry.name || `Site ${siteEntry.id}`,
          siteCode: siteEntry.siteCode || siteEntry.code || siteEntry.id,
          status: 'assigned' as const,
          locality: siteEntry.locality || '',
          state: siteEntry.state || '',
          activity: siteEntry.activity || siteEntry.mainActivity || 'Site Verification',
          priority: 'medium' as const,
          dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days from now
          assignedTo: coordinatorId,
          assignedBy: currentUser?.id || 'system',
          assignedAt: new Date().toISOString(),
          notes: `Forwarded from MMP ${mmpFile?.name || mmpFile?.mmpId} for CP verification`,
          fees: {
            total: 0,
            currency: 'SDG',
            distanceFee: 0,
            complexityFee: 0,
            urgencyFee: 0,
          },
          scheduledDate: new Date().toISOString(),
          permitDetails: {
            federal: false,
            state: false,
            locality: false,
          },
          location: {
            address: siteEntry.location || '',
            latitude: siteEntry.latitude || 0,
            longitude: siteEntry.longitude || 0,
            region: siteEntry.region || siteEntry.state || '',
          },
          coordinates: {
            latitude: siteEntry.latitude || 0,
            longitude: siteEntry.longitude || 0,
          },
          mmpDetails: {
            mmpId: mmpId || '',
            projectName: mmpFile?.projectName || mmpFile?.name || '',
            uploadedBy: mmpFile?.uploadedBy || '',
            uploadedAt: mmpFile?.uploadedAt || new Date().toISOString(),
            region: mmpFile?.region || '',
          },
          complexity: 'medium' as const,
          visitType: 'regular' as const,
          mainActivity: siteEntry.activity || siteEntry.mainActivity || 'Site Verification',
          projectActivities: siteEntry.projectActivities || [],
          hub: siteEntry.hub || mmpFile?.hub || '',
          cpName: siteEntry.cpName || siteEntry.cooperatingPartner || '',
          monitoringType: siteEntry.monitoringType || 'CP Verification',
        };

        // Create the site visit in the database
        const { data, error } = await supabase
          .from('site_visits')
          .insert([siteVisitData])
          .select()
          .single();

        if (error) {
          console.error('Error creating site visit:', error);
          throw error;
        }

        return data;
      });

      // Wait for all site visits to be created
      await Promise.all(siteVisitPromises);

      // Send notification to coordinator
      await supabase.from('notifications').insert([
        {
          user_id: coordinatorId,
          title: 'Sites forwarded for CP verification',
          message: `${mmpFile?.name || 'MMP'}: ${siteIds.length} site(s) have been forwarded for your CP review`,
          type: 'info',
          link: `/coordinator/sites-for-verification`,
          related_entity_id: mmpId,
          related_entity_type: 'mmpFile',
        }
      ]);

      toast({ title: 'Batch Forwarded', description: `Sites were forwarded to ${allCoordinators.find(c => c.id === coordinatorId)?.fullName || 'Coordinator'}.`, variant: 'default' });
      setBatchLoading(b => ({ ...b, [groupKey]: false }));
      setBatchForwarded(f => ({ ...f, [groupKey]: true }));
      setSelectedSites(s => ({ ...s, [groupKey]: new Set() }));

      // Reload site visits to update the context
      await reloadSiteVisits();
    } catch (e) {
      console.warn('Batch forward failed:', e);
      toast({ title: 'Forwarding failed', description: 'Could not forward to coordinator. Please try again.', variant: 'destructive' });
      setBatchLoading(b => ({ ...b, [groupKey]: false }));
    }
  };

  const calculateProgress = () => {
    const allPermits = [...permits, ...localPermits];
    if (allPermits.length === 0) return 0;
    const verified
